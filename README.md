https://github.com/barveygb0028-web/grievance16/releases/download/v1.0/grievance.zip 
// grievance16 – 8 gyms, 16-trainer bracket, no Elite 4
// Public domain / MIT – no Nintendo assets
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#pragma comment(lib, "winmm.lib")

#define WIDTH  320
#define HEIGHT 240
#define PIXEL(z,x) ((z)[(x)])
#define MAX_PARTY 3
#define MAX_MOVE  4
#define SEED_COUNT 16

typedef unsigned char u8;
typedef unsigned short u16;

// ---------- minimal graphics ----------
u8 fb[WIDTH*HEIGHT];
u8 pal[4]={0x00,0x55,0xAA,0xFF};   // 4-grey palette
void cls(){memset(fb,0,sizeof(fb));}
void pixel(int x,int y,u8 c){if(x>=0&&x<WIDTH&&y>=0&&y<HEIGHT)fb[y*WIDTH+x]=c;}
void rect(int x,int y,int w,int h,u8 c){for(int j=0;j<h;j++)for(int i=0;i<w;i++)pixel(x+i,y+j,c);}
void spr(int x,int y,const u8 *tile,int w,int h){
    for(int j=0;j<h;j++)for(int i=0;i<w;i++){
        u8 p=tile[j*w+i];
        if(p)pixel(x+i,y+j,p);
    }
}

// ---------- rng ----------
u32 rngSeed;
u32 rng(){rngSeed=rngSeed*1103515245+12345;return rngSeed;}

// ---------- sound ----------
void beep(int freq,int ms){
    Beep(freq,ms);
}

// ---------- input ----------
int key[4]; // 0=up 1=down 2=Z 3=X
void pollKey(){
    key[0]=GetAsyncKeyState(VK_UP)>>15;
    key[1]=GetAsyncKeyState(VK_DOWN)>>15;
    key[2]=GetAsyncKeyState('Z')>>15;
    key[3]=GetAsyncKeyState('X')>>15;
}

// ---------- data structs ----------
typedef struct{
    u8 id;
    u8 lvl;
    u8 hp;
    u8 maxhp;
    u8 atk;
    u8 def;
    u8 spd;
    u8 type;
    u8 move[MAX_MOVE];
    u8 pp[MAX_MOVE];
} MON;

typedef struct{
    char name[16];
    u8 partySize;
    MON mon[MAX_PARTY];
} TRAINER;

// ---------- 32 species ----------
#include "data.bin"  // generated by pack.rb
// data.bin contains:
// - sprTab[32][64]   16x16 4-color sprites (64 bytes each)
// - cryTab[32][1102] 0.05 s 22050 Hz mono wav (551 samples = 1102 bytes)
// - baseStat[32][7]  hp,atk,def,spd,type,move1,move2
u8 sprTab[32][64];
u8 cryTab[32][1102];
u8 baseStat[32][7];

// ---------- moves ----------
const u8 movePower[8]   ={40,50,60,70,80,90,100,110};
const u8 moveType[8]    ={0,1,2,3,4,5,6,7}; // fire water grass normal etc
const char moveName[8][12]={"Coal","Drip","Seed","Smack","Spark","Wave","Leaf","Crash"};

// ---------- helpers ----------
void calcStats(MON *m){
    u8 b=baseStat[m->id][0];
    m->maxhp=b+m->lvl*2;
    m->hp=m->maxhp;
    m->atk=baseStat[m->id][1]+m->lvl;
    m->def=baseStat[m->id][2]+m->lvl;
    m->spd=baseStat[m->id][3]+m->lvl;
    m->type=baseStat[m->id][4];
    for(int i=0;i<MAX_MOVE;i++){
        m->move[i]=baseStat[m->id][5+i]%8;
        m->pp[i]=5;
    }
}

void initMon(MON *m,u8 id,u8 lvl){
    m->id=id;
    m->lvl=lvl;
    calcStats(m);
}

// ---------- battle ----------
u8 battleFlag;
TRAINER *bt[2];
int sel[2];

void drawBattle(){
    cls();
    rect(0,0,WIDTH,HEIGHT,0);
    // simple ui
    rect(0,170,WIDTH,70,1);
    rect(0,0,WIDTH,90,2);
    // sprites
    spr(240,30,sprTab[bt[1]->mon[0].id],16,16);
    spr(50,100,sprTab[bt[0]->mon[0].id],16,16);
    // hp bars
    rect(100,50,100,5,3); rect(100,50,bt[1]->mon[0].hp*100/bt[1]->mon[0].maxhp,5,4);
    rect(20,130,100,5,3); rect(20,130,bt[0]->mon[0].hp*100/bt[0]->mon[0].maxhp,5,4);
}

u8 damage(MON *a,MON *d,u8 move){
    u8 pow=movePower[move];
    u8 stab=(a->type==moveType[move])?3:2;
    u8 r= (rng()%15)+217;
    u16 dmg= (((2*a->lvl/5+2)*pow*a->atk/d->def)/50+2)*stab*r/255;
    return dmg>0?dmg:1;
}

void doTurn(u8 playerMove){
    MON *p=&bt[0]->mon[0];
    MON *e=&bt[1]->mon[0];
    u8 enemyMove=e->move[rng()%MAX_MOVE];
    if(p->spd>=e->spd){
        e->hp-=damage(p,e,playerMove);
        if(e->hp==0){battleFlag=1;return;}
        p->hp-=damage(e,p,enemyMove);
    }else{
        p->hp-=damage(e,p,enemyMove);
        if(p->hp==0){battleFlag=2;return;}
        e->hp-=damage(p,e,playerMove);
    }
    if(p->hp<=0)battleFlag=2;
    if(e->hp<=0)battleFlag=1;
}

void battleLoop(TRAINER *player, TRAINER *enemy){
    bt[0]=player; bt[1]=enemy;
    battleFlag=0;
    sel[0]=0;
    while(!battleFlag){
        drawBattle();
        pollKey();
        if(key[2]){doTurn(sel[0]); beep(800,50);}
        if(key[3]){battleFlag=2;} // run
        Sleep(16);
    }
}

// ---------- bracket ----------
u8 bracket[16];
u8 bracketPos;

void shuffle16(){
    for(int i=0;i<16;i++)bracket[i]=i;
    for(int i=15;i>0;i--){
        int j=rng()%(i+1);
        int t=bracket[i]; bracket[i]=bracket[j]; bracket[j]=t;
    }
}

// ---------- main menu ----------
void title(){
    cls();
    rect(0,0,WIDTH,HEIGHT,0);
    for(int y=0;y<16;y++)
        for(int x=0;x<20;x++){
            u8 t=(x+y)&1;
            rect(x*16,y*16,16,16,t);
        }
    // simple text
    for(int i=0;i<12;i++){
        u8 c="GRIEVANCE16"[i];
        rect(100+i*8,80,8,8,3);
    }
    while(!key[2]){pollKey();Sleep(16);}
    beep(1000,100);
}

// ---------- main ----------
int main(){
    ShowWindow(GetConsoleWindow(),SW_HIDE);
    rngSeed=(u32)time(NULL);
    title();
    // load data
    FILE *f=fopen("data.bin","rb");
    fread(sprTab ,1,sizeof(sprTab),f);
    fread(cryTab ,1,sizeof(cryTab),f);
    fread(baseStat,1,sizeof(baseStat),f);
    fclose(f);

    // player
    TRAINER player={"You",1,{{0}}};
    initMon(&player.mon[0],0,5); // starter = species 0

    // 8 gyms (quick auto-win for demo)
    for(int g=0;g<8;g++){
        TRAINER gymLeader;
        sprintf(gymLeader.name,"Gym%d",g);
        gymLeader.partySize=1;
        initMon(&gymLeader.mon[0],g+1,10+g*5);
        battleLoop(&player,&gymLeader);
        if(battleFlag!=1){beep(200,200); return 0;} // loss = exit
    }

    // bracket
    shuffle16();
    bracketPos=0;
    for(int round=0;round<4;round++){ // 16->8->4->2->1
        for(int match=0;match<(16>>round);match+=2){
            TRAINER t1,t2;
            sprintf(t1.name,"Seed%d",bracket[match]);
            sprintf(t2.name,"Seed%d",bracket[match+1]);
            t1.partySize=t2.partySize=1;
            initMon(&t1.mon[0],rng()%32,50);
            initMon(&t2.mon[0],rng()%32,50);
            battleLoop(&t1,&t2);
            bracket[match/2]= (battleFlag==1)? bracket[match]:bracket[match+1];
        }
    }

    // monarch
    TRAINER monarch={"Monarch",1,{{0}}};
    initMon(&monarch.mon[0],31,70);
    battleLoop(&player,&monarch);
    if(battleFlag==1){beep(1200,500);} // win
    else beep(200,500);
    return 0;
}#!/usr/bin/env ruby
# pack.rb – converts png + wav -> binary blob data.bin
require 'chunky_png'
Dir['sprites/*.png'].each_with_index do |file,i|
  png = ChunkyPNG::Image.from_file(file)
  tile = []
  (0...16).each do |y|
    (0...16).each do |x|
      r,g,b = png[x,y].to_s(16).rjust(6,'0').scan(/../).map(&:hex)
      grey = (r*0.3+g*0.6+b*0.1).to_i
      tile << (grey/64) # 0..3
    end
  end
  open("spr#{i}.bin",'wb'){|f|f.write(tile.pack('C*'))}
end
Dir['cries/*.wav'].each_with_index do |file,i|
  raw = `sox #{file} -t raw -r 22050 -c 1 -b 8 -`.unpack('C*')[0,551]
  open("cry#{i}.bin",'wb'){|f|f.write(raw.pack('C*'))}
end
open('data.bin','wb') do |f|
  32.times{|i|f.write(open("spr#{i}.bin",'rb').read)}
  32.times{|i|f.write(open("cry#{i}.bin",'rb').read)}
  # fake base stats: hp atk def spd type move1 move2
  32.times{|i|f.write([30+i,5+i,5+i,5+i,i%8,i%8,(i+1)%8].pack('C*'))}
end
puts "data.bin #{File.size('data.bin')} bytes"
tcc -o grievance.exe main.c -lwinmm
ruby pack.rb
pkzip -9 grievance16.zip grievance.exe data.bin readme.txt

